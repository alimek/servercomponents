import ClientWaterfallDiagram from "../the-problems-rscs-solve/client-waterfall-diagram.tsx"
import ServerRenderingAnimation from "../animations/server-rendering-animation.tsx"
import HydrationAnimation from "../animations/hydration-animation.tsx"
import Tweet from "@/components/tweet.tsx"
import ReactRouterLogo from "@/components/react-router-logo";
import RemixLogo from "@/components/remix-logo";
import NextJSLogo from "@/components/nextjs-logo";
import MetaLogo from "@/components/meta-logo";
import Footer from "@/components/footer.tsx";

# What are React Server Components (RSCs)?

React server components are React components that run *only* on the server, a different paradigm from the mental model we've grown accustomed to where React simply runs on the client (in the browser).

With this new paradigm, the main difference comes from the output of the component and where the component runs, not necessarily the way you build (at least not so much).

There's still a shift in the way you think about building React apps, but it's not as drastic as you might think, and the goal of this website is to explain what changed, why things changed, and how to think about building React apps with this new paradigm.

This site *is* completely open sourced, so if you're interested in adding anything, changing anything, correcting any mistakes, or just want to see how it works, you can check out the [repo on GitHub](https://github.com/ricardonunez-io/servercomponents).

### Server Side Rendering

Running React components on the server might seem familiar if you've heard of "server-side rendering" or SSR (a la [<NextJSLogo width={28} /> Next.js](https://nextjs.org) or [<RemixLogo width={20} /> Remix](https://remix.run)), which is when you pre-render your React components on the *server*, and then *hydrate it* on the client.

What pre-rendering means is that we're essentially rendering your React component tree (pre-animations, pre-hooks, etc.) as HTML and sending it to the browser, using React's `renderToString(){:js}` method.

<ServerRenderingAnimation caption={"Press play for a rough visualization on what server-side rendering does."}/>

You can think of that HTML string as a screenshot of the very first frame you see when a page loads before any animations, state changes, effects, etc. happen. For example:

```js
`<html><head><title>My App</></head><body><div id="root"><div class="App"><h1>Hello World!</></div></div></body></html>`
```

Here's the same thing, but formatted for readability:

```js
`<html>
  <head>
    <title>My App</title>
  </head>
  <body>
    <div id="root">
      <div class="App">
        <h1>Hello World!</h1>
      </div>
    </div>
  </body>
</html>`
```

This string of HTML is then sent to the browser to render, and then *hydrated* by React once the browser loads React and all the necessary Javascript.

Now, while frameworks like Next and Remix are widely known for their capabilities in server rendering your React app, it's not quite the same as *running* a React component on the server, because there's still the step of hydration.

"Hydration" essentially means re-rendering all of that HTML, *plus* the necessary JS in the user's *browser* so that the page can become interactive.

So even though SSR means that your user sees your content on their screen, it doesn't mean they can use the page yet.

React still has to do a lot of work in terms of binding your React components from the virtual DOM to the actual DOM, setting up event listeners/handlers, etc.

<HydrationAnimation
	caption={"â†‘ React needs to bind these things to your application behind the scenes before anything on the page can be interacted with (i.e. before you can navigate, click a button, etc.), even if the HTML is visible on the page."}/>

Even if you have a completely static page with no hooks, state, effects, click handlers, etc., React would *still* need to hydrate the page.

So the challenge SSR solved wasn't necessarily running React on servers to get rid of hydration, but rather giving the user content to look at while React loads up all the components.

### How are Server Components different from SSR?

Now, if hydration is still necessary using SSR, that means that your React logic (i.e. what gets called before the `return(){:js}` statement) still needs to run on the client. For now, let's ignore solutions like Next.js's [`getServerSideProps`](https://nextjs.org/docs/pages/api-reference/functions/get-server-side-props) and Remix [`loaders`](https://remix.run/docs/en/1.17.1/route/loader).

The reason why your component and its logic still runs on the client is because behind the scenes, Babel is transpiling your JSX into `React.createElement(){:js}` calls on the client-side.

These calls create React elements (JSON objects) that describe your components and tell the browser "these are the DOM nodes from the React virtual DOM that we'd like to add/change in the actual DOM".

For example, if we wanted to render a component in JSX that only contained a div that says "Hello World", we'd simply write:

```jsx
export default function HelloWorld() {
  return <div>Hello World</div>
}
```

And Babel would transpile that into `React.createElement(){:js}` calls which would output something like:

```json
{
  "type": "div",
  "props": {
    "children": "Hello World"
  }
}
```

> I'm, of course, oversimplifying this process quite a bit, but if you want a more explicit and tangible example of what it means to go from React in just an HTML file with `<script>{:html}` tags to JSX and what creating elements looks like a bit more under the hood, Kent C. Dodds' free intro to React course [here](https://egghead.io/courses/the-beginner-s-guide-to-react) explains it really well.

So even if you server-side render your application, that initial HTML output is just going to be overwritten by the output of those `React.createElement(){:js}` calls, and the HTML is then going to be considered hydrated.

The difference, then, between React Server Components and SSR is that the process SSR takes to render your React app is:

1. Having the server render a snapshot of your JSX's initial HTML output with `renderToString(){:js}` and sending that to the browser

2. Sending your component tree's JSX from the server to the browser

3. Creating React elements (which, again, are just JSON representations of the DOM and your component tree) from that JSX in the browser with `React.createElement(){:js}` calls

4. Rendering those elements to the DOM to finish *hydrating* the HTML on the client

Instead, with server components, what you're sending to the browser are just React components that have already been rendered as React elements by the server.

That is to say the browser is getting the serialized output of your JSX directly from the server, instead of having to transpile the JSX itself client-side.

> That's certainly a lot to keep track of, but Ryan Florence, one of the creators of [<ReactRouterLogo width={30}/> React Router](https://reactrouter.com) and [<RemixLogo width={20} /> Remix](https://remix.run), had a great Tweet to explain this mental model as simply as possible:
>
> <Tweet id="1661717887319670784"/>
>
> Also, Dan Abramov's (from the React core team at <MetaLogo width={28}/> Meta) discussion on GitHub, ["RSC from Scratch. Pt. 1: Server Components"](https://github.com/reactwg/server-components/discussions/5), goes a lot more in depth on what it'd look like to recreate server components from the ground up, and I'd highly recommend reading that if you want to dive deeper into the technical details to clarify your own mental model.

Because these components are, for all intents and purposes, static *once they're loaded*, they don't *need* to hydrate, but they can refresh themselves, meaning if data changes on the page, React can re-render the components that are affected while maintaining state client-side.

The other benefit is that since it's running on the server, you have access to things like data fetching and file system access directly within components themselves.

So then, many people have the question: what happened to "regular React" or the React we all know?

Well, it's still there, but now, "regular" React components (i.e. React pre-Server Components) are called "client components".

Only the name changed, though, but they're exactly the same and nothing at all has changed about them in terms of functionality.

<Footer previousPost={"Home Page"} previousHref={"/"} nextPost={"The Problems React Server Components Solve"} nextHref={"/the-problems-rscs-solve"} />
